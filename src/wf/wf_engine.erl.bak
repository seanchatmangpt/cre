%% -*- erlang -*-
%%
%% CRE: common runtime environment for distributed programming languages
%%
%% Copyright 2015-2025 CRE Team
%%
%% Licensed under the Apache License, Version 2.0 (the "License");
%% you may not use this file except in compliance with the License.
%% You may obtain a copy of the License at
%%
%%     http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing, software
%% distributed under the License is distributed on an "AS IS" BASIS,
%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%% See the License for the specific language governing permissions and
%% limitations under the License.
%%
%% -------------------------------------------------------------------
%% @author CRE Team
%% @copyright 2025
%% @doc Workflow Engine - Core workflow execution engine
%%
%% This module provides the core workflow engine that manages workflow case
%% execution, work item lifecycle, receipts, and event emission.
%%
%% == Doctests ==
%%
%% Starting a workflow engine with a compiled spec:
%% ```erlang
%% > {ok, Eng} = wf_engine:start_link(#{
%% ..   spec => Compiled,
%% ..   org => Org,
%% ..   seed => 1,
%% ..   now => 0
%% .. }).
%% _
%% ```
%%
%% Starting a case and checking state:
%% ```erlang
%% > {ok, CaseId} = wf_engine:start_case(Eng, #{data => #{amount => 10}}, 0).
%% _
%% > wf_engine:case_state(Eng, CaseId).
%% running
%% ```
%%
%% Work item operations:
%% ```erlang
%% > [WI] = wf_engine:worklist(Eng, alice).
%% _
%% > maps:get(task, WI).
%% t1
%% ```
%%
%% Allocating and completing work:
%% ```erlang
%% > WiId = maps:get(wi, WI).
%% _
%% > ok = wf_engine:allocate(Eng, WiId, alice, 0).
%% ok
%% > ok = wf_engine:start_work(Eng, WiId, alice, 0).
%% ok
%% > ok = wf_engine:complete(Eng, WiId, alice, #{approved => true}, 0).
%% ok
%% ```
%%
%% Final state check:
%% ```erlang
%% > wf_engine:case_state(Eng, CaseId).
%% completed
%% > wf_engine:worklist(Eng, alice).
%% []
%% ```
%% @end
%% -------------------------------------------------------------------

-module(wf_engine).
-behaviour(gen_server).

%%====================================================================
%% Exports
%%====================================================================

%% API
-export([start_link/1]).
-export([start_case/3]).
-export([case_state/2]).
-export([worklist/2]).
-export([allocate/4, start_work/4, complete/5]).
-export([drain_receipts/2]).
-export([suspend_case/3, resume_case/3, cancel_case/3]).
-export([tick/2]).
-export([enabled/2]).
-export([drain_events/1]).
-export([service_reply/5]).
-export([publish/4]).
-export([case_log/2]).

%% gen_server callbacks
-export([init/1, handle_call/3, handle_cast/2, handle_info/2,
         code_change/3, terminate/2]).

%%====================================================================
%% Types
%%====================================================================

%%--------------------------------------------------------------------
%% @doc Unique identifier for a workflow case.
%%--------------------------------------------------------------------
-type case_id() :: binary().

%%--------------------------------------------------------------------
%% @doc Unique identifier for a work item.
%%--------------------------------------------------------------------
-type wi_id() :: binary().

%%--------------------------------------------------------------------
%% @doc User or resource identifier.
%%--------------------------------------------------------------------
-type user() :: atom() | binary().

%%--------------------------------------------------------------------
%% @doc Workflow case status.
%%--------------------------------------------------------------------
-type case_status() :: pending | running | suspended | cancelled |
                       completed | failed | scheduled.

%%--------------------------------------------------------------------
%% @doc Work item status.
%%--------------------------------------------------------------------
-type wi_status() :: offered | allocated | started | completed.

%%--------------------------------------------------------------------
%% @doc Receipt record for audit trail.
%%--------------------------------------------------------------------
-type receipt() :: #{
    before_hash := binary(),
    after_hash := binary(),
    move := pnet_receipt:move(),
    ts := integer()
}.

%%--------------------------------------------------------------------
%% @doc Work item record.
%%--------------------------------------------------------------------
-record(work_item, {
    wi_id :: wi_id(),
    case_id :: case_id(),
    task :: atom(),
    status :: wi_status(),
    assigned_to :: user() | undefined,
    data :: map() | undefined,
    created_at :: integer()
}).

-type work_item() :: #work_item{}.

%%--------------------------------------------------------------------
%% @doc Workflow case record.
%%--------------------------------------------------------------------
-record(wf_case, {
    case_id :: case_id(),
    status :: case_status(),
    work_items = #{} :: #{wi_id() => work_item()},
    data = #{} :: map(),
    receipts = [] :: [receipt()],
    events = [] :: [term()],
    log = [] :: [term()],
    marking :: pnet_types:marking(),
    rng_state :: pnet_choice:rng_state(),
    scheduled_at :: integer() | undefined,
    timestamps :: map()
}).

-type wf_case() :: #wf_case{}.

%%--------------------------------------------------------------------
%% @doc Engine state record.
%%--------------------------------------------------------------------
-record(engine_state, {
    spec :: map(),
    org :: map(),
    cases = #{} :: #{case_id() => wf_case()},
    timerq :: wf_timerq:timerq(),
    next_seq = 1 :: non_neg_integer(),
    current_time = 0 :: integer(),
    rng_state :: pnet_choice:rng_state()
}).

-type engine_state() :: #engine_state{}.

%%--------------------------------------------------------------------
%% @doc Service request event.
%%--------------------------------------------------------------------
-record(service_request, {
    req_id :: binary(),
    case_id :: case_id(),
    service :: atom(),
    data :: term(),
    timeout :: integer() | undefined
}).

-type service_request() :: #service_request{}.

%% Export types
-export_type([case_id/0, wi_id/0, user/0, case_status/0, wi_status/0,
             receipt/0, work_item/0, wf_case/0, engine_state/0]).

%%====================================================================
%% API Functions
%%====================================================================

%%--------------------------------------------------------------------
%% @doc Starts the workflow engine.
%%
%% @param Config Configuration map with spec, org, seed, now
%% @return {ok, Pid} | {error, Reason}
%%
%% @end
%%--------------------------------------------------------------------
-spec start_link(Config :: map()) -> {ok, pid()} | {error, term()}.

start_link(Config) ->
    gen_server:start_link(?MODULE, Config, []).

%%--------------------------------------------------------------------
%% @doc Starts a new workflow case.
%%
%% @param Engine Engine pid or name
%% @param Options Case options including data
%% @param Now Current time
%% @return {ok, CaseId} | {error, Reason}
%%
%% @end
%%--------------------------------------------------------------------
-spec start_case(Engine :: pid() | atom(), Options :: map(), Now :: integer()) ->
          {ok, case_id()} | {error, term()}.

start_case(Engine, Options, Now) ->
    gen_server:call(Engine, {start_case, Options, Now}).

%%--------------------------------------------------------------------
%% @doc Schedules a workflow case to start at a specific future time.
%%
%% The case is created in 'scheduled' status and will transition to 'running'
%% when the scheduled time is reached via tick/2. Scheduled cases can be
%% cancelled before they start.
%%
%% == Doctests ==
%%
%% ```erlang
%% > {ok, ScheduledId} = wf_engine:schedule_case(Eng, #{data => #{}}, 100, 0).
%% _
%% > wf_engine:case_state(Eng, ScheduledId).
%% scheduled
%% > wf_engine:tick(Eng, 100).
%% ok
%% > wf_engine:case_state(Eng, ScheduledId).
%% running
%% ```
%%
%% Cancelling before start:
%% ```erlang
%% > {ok, CancelId} = wf_engine:schedule_case(Eng, #{data => #{}}, 1000, 0).
%% _
%% > wf_engine:case_state(Eng, CancelId).
%% scheduled
%% > ok = wf_engine:cancel_case(Eng, CancelId, 10).
%% ok
%% > wf_engine:case_state(Eng, CancelId).
%% cancelled
%% ```
%%
%% @param Engine Engine pid or name
%% @param Options Case options including data
%% @param StartAt Time in milliseconds when case should start
%% @param Now Current time
%% @return {ok, CaseId} | {error, Reason}
%%
%% @end
%%--------------------------------------------------------------------
-spec schedule_case(Engine :: pid() | atom(), Options :: map(),
                    StartAt :: integer(), Now :: integer()) ->
          {ok, case_id()} | {error, term()}.

schedule_case(Engine, Options, StartAt, Now) ->
    gen_server:call(Engine, {schedule_case, Options, StartAt, Now}).

%%--------------------------------------------------------------------
%% @doc Gets the current state of a case.
%%
%% @param Engine Engine pid or name
%% @param CaseId Case identifier
%% @return case_status() | {error, not_found}
%%
%% @end
%%--------------------------------------------------------------------
-spec case_state(Engine :: pid() | atom(), CaseId :: case_id()) ->
          case_status() | {error, not_found}.

case_state(Engine, CaseId) ->
    gen_server:call(Engine, {case_state, CaseId}).

%%--------------------------------------------------------------------
%% @doc Gets the worklist for a user.
%%
%% Returns list of work items allocated to the user.
%%
%% @param Engine Engine pid or name
%% @param User User identifier
%% @return [work_item()]
%%
%% @end
%%--------------------------------------------------------------------
-spec worklist(Engine :: pid() | atom(), User :: user()) -> [work_item()].

worklist(Engine, User) ->
    gen_server:call(Engine, {worklist, User}).

%%--------------------------------------------------------------------
%% @doc Allocates a work item to a user.
%%
%% @param Engine Engine pid or name
%% @param WiId Work item identifier
%% @param User User identifier
%% @param Now Current time
%% @return ok | {error, Reason}
%%
%% @end
%%--------------------------------------------------------------------
-spec allocate(Engine :: pid() | atom(), WiId :: wi_id(), User :: user(), Now :: integer()) ->
          ok | {error, term()}.

allocate(Engine, WiId, User, Now) ->
    gen_server:call(Engine, {allocate, WiId, User, Now}).

%%--------------------------------------------------------------------
%% @doc Starts work on a work item.
%%
%% @param Engine Engine pid or name
%% @param WiId Work item identifier
%% @param User User identifier
%% @param Now Current time
%% @return ok | {error, Reason}
%%
%% @end
%%--------------------------------------------------------------------
-spec start_work(Engine :: pid() | atom(), WiId :: wi_id(), User :: user(), Now :: integer()) ->
          ok | {error, term()}.

start_work(Engine, WiId, User, Now) ->
    gen_server:call(Engine, {start_work, WiId, User, Now}).

%%--------------------------------------------------------------------
%% @doc Completes a work item with result data.
%%
%% @param Engine Engine pid or name
%% @param WiId Work item identifier
%% @param User User identifier
%% @param Data Result data
%% @param Now Current time
%% @return ok | {error, Reason}
%%
%% @end
%%--------------------------------------------------------------------
-spec complete(Engine :: pid() | atom(), WiId :: wi_id(), User :: user(),
               Data :: map(), Now :: integer()) ->
          ok | {error, term()}.

complete(Engine, WiId, User, Data, Now) ->
    gen_server:call(Engine, {complete, WiId, User, Data, Now}).

%%--------------------------------------------------------------------
%% @doc Drains all receipts from a case.
%%
%% Returns list of receipts with before_hash, after_hash, move.
%%
%% @param Engine Engine pid or name
%% @param CaseId Case identifier
%% @return [receipt()]
%%
%% @end
%%--------------------------------------------------------------------
-spec drain_receipts(Engine :: pid() | atom(), CaseId :: case_id()) -> [receipt()].

drain_receipts(Engine, CaseId) ->
    gen_server:call(Engine, {drain_receipts, CaseId}).

%%--------------------------------------------------------------------
%% @doc Suspends a running case.
%%
%% @param Engine Engine pid or name
%% @param CaseId Case identifier
%% @param Now Current time
%% @return ok | {error, Reason}
%%
%% @end
%%--------------------------------------------------------------------
-spec suspend_case(Engine :: pid() | atom(), CaseId :: case_id(), Now :: integer()) ->
          ok | {error, term()}.

suspend_case(Engine, CaseId, Now) ->
    gen_server:call(Engine, {suspend_case, CaseId, Now}).

%%--------------------------------------------------------------------
%% @doc Resumes a suspended case.
%%
%% @param Engine Engine pid or name
%% @param CaseId Case identifier
%% @param Now Current time
%% @return ok | {error, Reason}
%%
%% @end
%%--------------------------------------------------------------------
-spec resume_case(Engine :: pid() | atom(), CaseId :: case_id(), Now :: integer()) ->
          ok | {error, term()}.

resume_case(Engine, CaseId, Now) ->
    gen_server:call(Engine, {resume_case, CaseId, Now}).

%%--------------------------------------------------------------------
%% @doc Cancels a case.
%%
%% @param Engine Engine pid or name
%% @param CaseId Case identifier
%% @param Now Current time
%% @return ok | {error, Reason}
%%
%% @end
%%--------------------------------------------------------------------
-spec cancel_case(Engine :: pid() | atom(), CaseId :: case_id(), Now :: integer()) ->
          ok | {error, term()}.

cancel_case(Engine, CaseId, Now) ->
    gen_server:call(Engine, {cancel_case, CaseId, Now}).

%%--------------------------------------------------------------------
%% @doc Advances time for delayed starts.
%%
%% @param Engine Engine pid or name
%% @param Delta Time delta in milliseconds
%% @return ok
%%
%% @end
%%--------------------------------------------------------------------
-spec tick(Engine :: pid() | atom(), Delta :: integer()) -> ok.

tick(Engine, Delta) ->
    gen_server:cast(Engine, {tick, Delta}).

%%--------------------------------------------------------------------
%% @doc Gets enabled transitions for a case.
%%
%% @param Engine Engine pid or name
%% @param CaseId Case identifier
%% @return [atom()] List of enabled transition names
%%
%% @end
%%--------------------------------------------------------------------
-spec enabled(Engine :: pid() | atom(), CaseId :: case_id()) -> [atom()].

enabled(Engine, CaseId) ->
    gen_server:call(Engine, {enabled, CaseId}).

%%--------------------------------------------------------------------
%% @doc Drains all events from the engine.
%%
%% Returns list of service_request and service_timeout events.
%%
%% @param Engine Engine pid or name
%% @return [term()]
%%
%% @end
%%--------------------------------------------------------------------
-spec drain_events(Engine :: pid() | atom()) -> [term()].

drain_events(Engine) ->
    gen_server:call(Engine, drain_events).

%%--------------------------------------------------------------------
%% @doc Replies to a service request.
%%
%% @param Engine Engine pid or name
%% @param ReqId Request identifier
%% @param CaseId Case identifier
%% @param Reply Reply data
%% @param Now Current time
%% @return ok | {error, Reason}
%%
%% @end
%%--------------------------------------------------------------------
-spec service_reply(Engine :: pid() | atom(), ReqId :: binary(), CaseId :: case_id(),
                    Reply :: term(), Now :: integer()) ->
          ok | {error, term()}.

service_reply(Engine, ReqId, CaseId, Reply, Now) ->
    gen_server:call(Engine, {service_reply, ReqId, CaseId, Reply, Now}).

%%--------------------------------------------------------------------
%% @doc Publishes a message to an IPC channel.
%%
%% @param Engine Engine pid or name
%% @param CaseId Case identifier
%% @param Channel Channel name
%% @param Message Message payload
%% @return ok
%%
%% @end
%%--------------------------------------------------------------------
-spec publish(Engine :: pid() | atom(), CaseId :: case_id(),
              Channel :: atom() | binary(), Message :: term()) -> ok.

publish(Engine, CaseId, Channel, Message) ->
    gen_server:cast(Engine, {publish, CaseId, Channel, Message}).

%%--------------------------------------------------------------------
%% @doc Gets the event log for a case.
%%
%% @param Engine Engine pid or name
%% @param CaseId Case identifier
%% @return [term()] List of logged events
%%
%% @end
%%--------------------------------------------------------------------
-spec case_log(Engine :: pid() | atom(), CaseId :: case_id()) -> [term()].

case_log(Engine, CaseId) ->
    gen_server:call(Engine, {case_log, CaseId}).

%%--------------------------------------------------------------------
%% @doc Runs doctests for the module.
%%
%% @end
%%--------------------------------------------------------------------
-spec doctest_test() -> ok.

doctest_test() ->
    ok.

%%====================================================================
%% gen_server Callbacks
%%====================================================================

%%--------------------------------------------------------------------
%% @private
%% @doc Initializes the workflow engine.
%%
%% @end
%%--------------------------------------------------------------------
-spec init(Config :: map()) -> {ok, engine_state()}.

init(Config) ->
    Spec = maps:get(spec, Config, #{}),
    Org = maps:get(org, Config, #{}),
    Seed = maps:get(seed, Config, 1),
    Now = maps:get(now, Config, 0),
    RngState = pnet_choice:seed(Seed),
    {ok, #engine_state{
        spec = Spec,
        org = Org,
        timerq = wf_timerq:new(),
        current_time = Now,
        rng_state = RngState
    }}.

%%--------------------------------------------------------------------
%% @private
%% @doc Handles synchronous calls.
%%
%% @end
%%--------------------------------------------------------------------
-spec handle_call(Request :: term(), From :: {pid(), term()}, State :: engine_state()) ->
          {reply, term(), engine_state()}.

handle_call({start_case, Options, Now}, _From, State) ->
    Data = maps:get(data, Options, #{}),
    CaseId = generate_case_id(State#engine_state.next_seq),
    NextSeq = State#engine_state.next_seq + 1,

    %% Get initial places from spec
    Places = maps:get(places, State#engine_state.spec, [p_start, p_end]),
    InitMarking = pnet_marking:new(Places),

    %% Initialize marking with start token
    StartToken = maps:get(start_token, State#engine_state.spec, start),
    InitMarking2 = maps:put(p_start, [StartToken], InitMarking),

    %% Create case record
    Timestamps = #{
        created_at => Now,
        started_at => Now
    },

    Case = #wf_case{
        case_id = CaseId,
        status = running,
        marking = InitMarking2,
        data = Data,
        rng_state = State#engine_state.rng_state,
        timestamps = Timestamps
    },

    %% Process initial transitions
    Case2 = process_enabled(Case, State#engine_state.spec, Now),

    Cases = maps:put(CaseId, Case2, State#engine_state.cases),
    NewState = State#engine_state{cases = Cases, next_seq = NextSeq},

    {reply, {ok, CaseId}, NewState};

handle_call({schedule_case, Options, StartAt, Now}, _From, State) ->
    Data = maps:get(data, Options, #{}),
    CaseId = generate_case_id(State#engine_state.next_seq),
    NextSeq = State#engine_state.next_seq + 1,

    %% Validate StartAt is in the future
    case StartAt > Now of
        true ->
            %% Get initial places from spec
            Places = maps:get(places, State#engine_state.spec, [p_start, p_end]),
            InitMarking = pnet_marking:new(Places),

            %% Initialize marking with start token (not yet active)
            StartToken = maps:get(start_token, State#engine_state.spec, start),
            InitMarking2 = maps:put(p_start, [StartToken], InitMarking),

            %% Create case record in scheduled status
            Timestamps = #{
                created_at => Now,
                scheduled_for => StartAt
            },

            Case = #wf_case{
                case_id = CaseId,
                status = scheduled,
                marking = InitMarking2,
                data = Data,
                rng_state = State#engine_state.rng_state,
                scheduled_at = StartAt,
                timestamps = Timestamps
            },

            %% Arm timer to start the case at scheduled time
            TimerEvent = {produce, #{case_id => CaseId, action => start_case}},
            TimerKey = {scheduled_start, CaseId},
            NewTimerQ = wf_timerq:arm(State#engine_state.timerq, TimerKey, StartAt, TimerEvent),

            Cases = maps:put(CaseId, Case, State#engine_state.cases),
            NewState = State#engine_state{cases = Cases, next_seq = NextSeq, timerq => NewTimerQ},

            {reply, {ok, CaseId}, NewState};
        false ->
            {reply, {error, {invalid_start_time, StartAt, must_be_greater_than, Now}}, State}
    end;

handle_call({case_state, CaseId}, _From, State) ->
    case maps:get(CaseId, State#engine_state.cases, undefined) of
        undefined -> {reply, {error, not_found}, State};
        #wf_case{status = Status} -> {reply, Status, State}
    end;

handle_call({worklist, User}, _From, State) ->
    Worklist = lists:filter(
        fun(#work_item{assigned_to = Assigned, status = Status}) ->
            Assigned =:= User andalso Status =:= allocated
        end,
        extract_all_workitems(State#engine_state.cases)
    ),
    {reply, Worklist, State};

handle_call({allocate, WiId, User, Now}, _From, State) ->
    case find_workitem(WiId, State#engine_state.cases) of
        {ok, Case, #work_item{status = offered}} ->
            {NewCase, NewState} = update_workitem_status(
                Case, WiId, allocated, User, Now, State
            ),
            {reply, ok, NewState};
        {ok, _Case, #work_item{status = Other}} ->
            {reply, {error, {invalid_status, Other}}, State};
        error ->
            {reply, {error, not_found}, State}
    end;

handle_call({start_work, WiId, User, Now}, _From, State) ->
    case find_workitem(WiId, State#engine_state.cases) of
        {ok, Case, #work_item{status = allocated, assigned_to = User}} ->
            {NewCase, NewState} = update_workitem_status(
                Case, WiId, started, User, Now, State
            ),
            {reply, ok, NewState};
        {ok, _Case, #work_item{status = Status}} ->
            {reply, {error, {invalid_status, Status}}, State};
        error ->
            {reply, {error, not_found}, State}
    end;

handle_call({complete, WiId, User, Data, Now}, _From, State) ->
    case find_workitem(WiId, State#engine_state.cases) of
        {ok, Case, #work_item{status = started, assigned_to = User, task = Task}} ->
            %% Complete the work item
            {NewCase, NewState} = complete_workitem(Case, WiId, Task, Data, Now, State),
            {reply, ok, NewState};
        {ok, _Case, #work_item{status = Status}} ->
            {reply, {error, {invalid_status, Status}}, State};
        error ->
            {reply, {error, not_found}, State}
    end;

handle_call({drain_receipts, CaseId}, _From, State) ->
    case maps:get(CaseId, State#engine_state.cases, undefined) of
        undefined -> {reply, {error, not_found}, State};
        #wf_case{receipts = Receipts} = Case ->
            Case1 = Case#wf_case{receipts = []},
            Cases = maps:put(CaseId, Case1, State#engine_state.cases),
            {reply, lists:reverse(Receipts), State#engine_state{cases = Cases}}
    end;

handle_call({suspend_case, CaseId, Now}, _From, State) ->
    case maps:get(CaseId, State#engine_state.cases, undefined) of
        undefined -> {reply, {error, not_found}, State};
        #wf_case{status = running} = Case ->
            Case1 = Case#wf_case{status = suspended},
            Cases = maps:put(CaseId, Case1, State#engine_state.cases),
            {reply, ok, State#engine_state{cases = Cases}};
        #wf_case{status = Status} ->
            {reply, {error, {invalid_status, Status}}, State}
    end;

handle_call({resume_case, CaseId, Now}, _From, State) ->
    case maps:get(CaseId, State#engine_state.cases, undefined) of
        undefined -> {reply, {error, not_found}, State};
        #wf_case{status = suspended} = Case ->
            Case1 = Case#wf_case{status = running},
            Case2 = process_enabled(Case1, State#engine_state.spec, Now),
            Cases = maps:put(CaseId, Case2, State#engine_state.cases),
            {reply, ok, State#engine_state{cases = Cases}};
        #wf_case{status = Status} ->
            {reply, {error, {invalid_status, Status}}, State}
    end;

handle_call({cancel_case, CaseId, Now}, _From, State) ->
    case maps:get(CaseId, State#engine_state.cases, undefined) of
        undefined -> {reply, {error, not_found}, State};
        #wf_case{status = scheduled} = Case ->
            %% Remove from timer queue and cancel
            TimerKey = {scheduled_start, CaseId},
            NewTimerQ = wf_timerq:disarm(State#engine_state.timerq, TimerKey),
            Case1 = Case#wf_case{
                status = cancelled,
                timestamps = maps:put(cancelled_at, Now, Case#wf_case.timestamps)
            },
            Cases = maps:put(CaseId, Case1, State#engine_state.cases),
            {reply, ok, State#engine_state{cases = Cases, timerq = NewTimerQ}};
        #wf_case{} = Case ->
            %% Regular case cancel (already running, suspended, etc.)
            Case1 = Case#wf_case{
                status = cancelled,
                timestamps = maps:put(cancelled_at, Now, Case#wf_case.timestamps)
            },
            Cases = maps:put(CaseId, Case1, State#engine_state.cases),
            {reply, ok, State#engine_state{cases = Cases}}
    end;

handle_call({enabled, CaseId}, _From, State) ->
    case maps:get(CaseId, State#engine_state.cases, undefined) of
        undefined -> {reply, {error, not_found}, State};
        #wf_case{marking = Marking} = Case ->
            Enabled = find_enabled_transitions(Marking, State#engine_state.spec),
            {reply, Enabled, State}
    end;

handle_call(drain_events, _From, State) ->
    %% Extract all events from all cases
    AllEvents = lists:flatmap(
        fun(#wf_case{events = Events}) -> lists:reverse(Events) end,
        maps:values(State#engine_state.cases)
    ),
    %% Clear events from cases
    Cases1 = maps:map(
        fun(_CaseId, Case) -> Case#wf_case{events = []} end,
        State#engine_state.cases
    ),
    {reply, AllEvents, State#engine_state{cases = Cases1}};

handle_call({service_reply, ReqId, CaseId, Reply, Now}, _From, State) ->
    case maps:get(CaseId, State#engine_state.cases, undefined) of
        undefined -> {reply, {error, not_found}, State};
        #wf_case{} = Case ->
            %% Inject reply token and process
            Case1 = inject_service_reply(Case, ReqId, Reply, Now),
            Cases = maps:put(CaseId, Case1, State#engine_state.cases),
            {reply, ok, State#engine_state{cases = Cases}}
    end;

handle_call({case_log, CaseId}, _From, State) ->
    case maps:get(CaseId, State#engine_state.cases, undefined) of
        undefined -> {reply, {error, not_found}, State};
        #wf_case{log = Log} -> {reply, lists:reverse(Log), State}
    end;

handle_call(_Request, _From, State) ->
    {reply, {error, bad_msg}, State}.

%%--------------------------------------------------------------------
%% @private
%% @doc Handles asynchronous casts.
%%
%% @end
%%--------------------------------------------------------------------
-spec handle_cast(Request :: term(), State :: engine_state()) ->
          {noreply, engine_state()}.

handle_cast({tick, Delta}, State) ->
    NewTime = State#engine_state.current_time + Delta,

    %% Poll timer queue for expired timers
    {TimerEvents, NewTimerQ} = wf_timerq:poll(State#engine_state.timerq, NewTime),

    %% Process timer events (inject tokens into cases)
    Cases1 = lists:foldl(
        fun({produce, ProduceMap}, AccCases) ->
            %% Find target case from produce map
            case maps:get(case_id, ProduceMap) of
                undefined -> AccCases;
                CaseId ->
                    case maps:get(CaseId, AccCases, undefined) of
                        undefined -> AccCases;
                        #wf_case{} = Case ->
                            Case1 = inject_tokens(Case, ProduceMap, NewTime),
                            maps:put(CaseId, Case1, AccCases)
                    end
            end
        end,
        State#engine_state.cases,
        TimerEvents
    ),

    {noreply, State#engine_state{timerq = NewTimerQ, current_time = NewTime,
                                 cases = Cases1}};

handle_cast({publish, CaseId, Channel, Message}, State) ->
    %% Log the publish event
    case maps:get(CaseId, State#engine_state.cases, undefined) of
        undefined ->
            {noreply, State};
        #wf_case{log = Log} = Case ->
            LogEntry = {publish, Channel, Message},
            Case1 = Case#wf_case{log = [LogEntry | Log]},
            Cases = maps:put(CaseId, Case1, State#engine_state.cases),
            {noreply, State#engine_state{cases = Cases}}
    end;

handle_cast(_Request, State) ->
    {noreply, State}.

%%--------------------------------------------------------------------
%% @private
%% @doc Handles non-gen_server messages.
%%
%% @end
%%--------------------------------------------------------------------
-spec handle_info(Info :: term(), State :: engine_state()) ->
          {noreply, engine_state()}.

handle_info(_Info, State) ->
    {noreply, State}.

%%--------------------------------------------------------------------
%% @private
%% @doc Handles code change during hot code upgrade.
%%
%% @end
%%--------------------------------------------------------------------
-spec code_change(OldVsn :: term(), State :: engine_state(), Extra :: term()) ->
          {ok, engine_state()}.

code_change(_OldVsn, State, _Extra) ->
    {ok, State}.

%%--------------------------------------------------------------------
%% @private
%% @doc Cleanup on termination.
%%
%% @end
%%--------------------------------------------------------------------
-spec terminate(Reason :: term(), State :: engine_state()) -> ok.

terminate(_Reason, _State) ->
    ok.

%%====================================================================
%% Internal Functions
%%====================================================================

%%--------------------------------------------------------------------
%% @private
%% @doc Generates a unique case ID.
%%
%% @end
%%--------------------------------------------------------------------
-spec generate_case_id(non_neg_integer()) -> case_id().

generate_case_id(Seq) ->
    Unique = crypto:hash(md5, term_to_binary({self(), Seq, erlang:unique_integer()})),
    Hex = binary:encode_hex(Unique),
    <<"case_", Hex/binary>>.

%%--------------------------------------------------------------------
%% @private
%% @doc Extracts all work items from all cases.
%%
%% @end
%%--------------------------------------------------------------------
-spec extract_all_workitems(#{case_id() => wf_case()}) -> [work_item()].

extract_all_workitems(Cases) ->
    lists:flatmap(
        fun(#wf_case{work_items = WIs}) -> maps:values(WIs) end,
        maps:values(Cases)
    ).

%%--------------------------------------------------------------------
%% @private
%% @doc Finds a work item by ID across all cases.
%%
%% Returns {ok, Case, WorkItem} or error.
%%
%% @end
%%--------------------------------------------------------------------
-spec find_workitem(wi_id(), #{case_id() => wf_case()}) ->
          {ok, wf_case(), work_item()} | error.

find_workitem(WiId, Cases) ->
    maps:fold(
        fun(CaseId, #wf_case{work_items = WIs} = Case, Acc) ->
            case maps:get(WiId, WIs, undefined) of
                undefined -> Acc;
                WI -> {ok, Case, WI}
            end
        end,
        error,
        Cases
    ).

%%--------------------------------------------------------------------
%% @private
%% @doc Updates a work item's status.
%%
%% @end
%%--------------------------------------------------------------------
-spec update_workitem_status(wf_case(), wi_id(), wi_status(), user(), integer(),
                             engine_state()) ->
          {wf_case(), engine_state()}.

update_workitem_status(#wf_case{work_items = WIs} = Case, WiId, Status, User, Now, State) ->
    WI = maps:get(WiId, WIs),
    WI1 = WI#work_item{status = Status, assigned_to = User},
    WIs1 = maps:put(WiId, WI1, WIs),
    Case1 = Case#wf_case{work_items = WIs1},
    Cases = maps:put(Case1#wf_case.case_id, Case1, State#engine_state.cases),
    NewState = State#engine_state{cases = Cases},

    %% Persist work item status change
    ok = persist_case(Case1, NewState),
    ok = persist_event(Case1#wf_case.case_id,
                       {workitem_status_changed, WiId, Status, User, Now},
                       NewState),

    {Case1, NewState}.

%%--------------------------------------------------------------------
%% @private
%% @doc Completes a work item and processes transitions.
%%
%% @end
%%--------------------------------------------------------------------
-spec complete_workitem(wf_case(), wi_id(), atom(), map(), integer(), engine_state()) ->
          {wf_case(), engine_state()}.

complete_workitem(#wf_case{work_items = WIs, marking = Marking, data = CaseData} = Case,
                   WiId, Task, Data, Now, State) ->
    %% Update work item status
    WI = maps:get(WiId, WIs),
    WI1 = WI#work_item{status = completed},
    WIs1 = maps:put(WiId, WI1, WIs),

    %% Merge data into case data
    NewCaseData = maps:merge(CaseData, Data),

    %% Create completion receipt
    BeforeHash = pnet_marking:hash(Marking),

    %% Fire the transition for this task
    Spec = State#engine_state.spec,
    ProduceMap = fire_transition(Task, Data, Spec),

    %% Update marking
    Marking1 = apply_produce_map(Marking, ProduceMap),
    AfterHash = pnet_marking:hash(Marking1),

    %% Create receipt
    Move = #{
        trsn => Task,
        mode => #{},
        produce => ProduceMap
    },
    Receipt = pnet_receipt:make(BeforeHash, AfterHash, Move),

    %% Update case
    Case1 = Case#wf_case{
        work_items = WIs1,
        marking = Marking1,
        data = NewCaseData,
        receipts = [Receipt | Case#wf_case.receipts],
        timestamps = maps:put(updated_at, Now, Case#wf_case.timestamps)
    },

    %% Check for completion
    Case2 = check_completion(Case1, Spec, Now),

    %% Process enabled transitions
    Case3 = process_enabled(Case2, Spec, Now),

    Cases = maps:put(Case3#wf_case.case_id, Case3, State#engine_state.cases),
    NewState = State#engine_state{cases = Cases},

    %% Persist case state after work item completion
    ok = persist_case(Case3, NewState),
    ok = persist_event(Case3#wf_case.case_id,
                       {workitem_completed, WiId, Task, Now},
                       NewState),

    {Case3, NewState}.

%%--------------------------------------------------------------------
%% @private
%% @doc Checks if case should be completed.
%%
%% @end
%%--------------------------------------------------------------------
-spec check_completion(wf_case(), map(), integer()) -> wf_case().

check_completion(#wf_case{marking = Marking} = Case, Spec, Now) ->
    EndPlace = maps:get(end_place, Spec, p_end),
    case maps:get(EndPlace, Marking, []) of
        [_|_] ->
            Case#wf_case{
                status = completed,
                timestamps = maps:put(completed_at, Now, Case#wf_case.timestamps)
            };
        [] ->
            Case
    end.

%%--------------------------------------------------------------------
%% @private
%% @doc Processes all enabled transitions.
%%
%% @end
%%--------------------------------------------------------------------
-spec process_enabled(wf_case(), map(), integer()) -> wf_case().

process_enabled(#wf_case{marking = Marking, rng_state = RngState} = Case, Spec, Now) ->
    Transitions = maps:get(transitions, Spec, #{}),

    %% Find enabled transitions
    Enabled = lists:filter(
        fun({Trsn, _Def}) ->
            is_transition_enabled(Trsn, Marking, Spec)
        end,
        maps:to_list(Transitions)
    ),

    %% Fire enabled transitions (non-deterministically pick one if multiple)
    case Enabled of
        [] ->
            Case;
        _ ->
            %% Use deterministic choice to pick transition
            TrsnNames = [T || {T, _} <- Enabled],
            {Trsn, Def} = case length(TrsnNames) of
                1 -> hd(Enabled);
                _ -> pick_transition(Enabled, RngState)
            end,
            fire_enabled_transition(Case, Trsn, Def, Spec, Now)
    end.

%%--------------------------------------------------------------------
%% @private
%% @doc Picks a transition deterministically based on RNG state.
%%
%% @end
%%--------------------------------------------------------------------
-spec pick_transition([{atom(), term()}], pnet_choice:rng_state()) ->
          {atom(), term()}.

pick_transition(Transitions, RngState) ->
    {Picked, _NewRng} = pnet_choice:pick(Transitions, RngState),
    Picked.

%%--------------------------------------------------------------------
%% @private
%% @doc Checks if a transition is enabled.
%%
%% @end
%%--------------------------------------------------------------------
-spec is_transition_enabled(atom(), pnet_types:marking(), map()) -> boolean().

is_transition_enabled(Trsn, Marking, Spec) ->
    Transitions = maps:get(transitions, Spec, #{}),
    case maps:get(Trsn, Transitions, undefined) of
        undefined -> false;
        Def ->
            Preset = maps:get(preset, Def, []),
            lists:all(
                fun(Place) ->
                    case maps:get(Place, Marking, []) of
                        [] -> false;
                        _ -> true
                    end
                end,
                Preset
            )
    end.

%%--------------------------------------------------------------------
%% @private
%% @doc Finds all enabled transitions for a marking.
%%
%% @end
%%--------------------------------------------------------------------
-spec find_enabled_transitions(pnet_types:marking(), map()) -> [atom()].

find_enabled_transitions(Marking, Spec) ->
    Transitions = maps:get(transitions, Spec, #{}),
    lists:filter(
        fun(Trsn) -> is_transition_enabled(Trsn, Marking, Spec) end,
        maps:keys(Transitions)
    ).

%%--------------------------------------------------------------------
%% @private
%% @doc Fires an enabled transition.
%%
%% @end
%%--------------------------------------------------------------------
-spec fire_enabled_transition(wf_case(), atom(), term(), map(), integer()) -> wf_case().

fire_enabled_transition(#wf_case{marking = Marking, data = Data} = Case, Trsn, Def, Spec, Now) ->
    %% Create task token if this is a human task
    IsTask = maps:get(is_task, Def, false),
    TaskPlace = maps:get(task_place, Def, p_task),

    BeforeHash = pnet_marking:hash(Marking),

    case IsTask of
        true ->
            %% Create work item
            WiId = generate_wi_id(),
            WI = #work_item{
                wi_id = WiId,
                case_id = Case#wf_case.case_id,
                task = Trsn,
                status = offered,
                data = Data,
                created_at = Now
            },
            WIs = maps:put(WiId, WI, Case#wf_case.work_items),

            %% Create produce map with task token
            ProduceMap = maps:get(produce, Def, #{TaskPlace => [{task, WiId}]}),

            %% Update marking
            Marking1 = consume_preset(Marking, maps:get(preset, Def, [])),
            Marking2 = apply_produce_map(Marking1, ProduceMap),
            AfterHash = pnet_marking:hash(Marking2),

            %% Create receipt
            Move = #{trsn => Trsn, mode => #{}, produce => ProduceMap},
            Receipt = pnet_receipt:make(BeforeHash, AfterHash, Move),

            %% Log event
            LogEntry = {task_created, Trsn, WiId, Now},

            Case#wf_case{
                marking = Marking2,
                work_items = WIs,
                receipts = [Receipt | Case#wf_case.receipts],
                log = [LogEntry | Case#wf_case.log]
            };
        false ->
            %% Regular transition
            ProduceMap = maps:get(produce, Def, #{}),

            %% Check if this is a service call
            IsService = maps:get(is_service, Def, false),

            Marking1 = consume_preset(Marking, maps:get(preset, Def, [])),
            Marking2 = apply_produce_map(Marking1, ProduceMap),
            AfterHash = pnet_marking:hash(Marking2),

            %% Create receipt
            Move = #{trsn => Trsn, mode => #{}, produce => ProduceMap},
            Receipt = pnet_receipt:make(BeforeHash, AfterHash, Move),

            %% Emit service request event if applicable
            Events = case IsService of
                true ->
                    ReqId = generate_req_id(),
                    Service = maps:get(service, Def, Trsn),
                    Timeout = maps:get(timeout, Def, 5000),
                    [#service_request{
                        req_id = ReqId,
                        case_id = Case#wf_case.case_id,
                        service = Service,
                        data = Data,
                        timeout = Timeout
                    }];
                false ->
                    []
            end,

            Case#wf_case{
                marking = Marking2,
                receipts = [Receipt | Case#wf_case.receipts],
                events = Events ++ Case#wf_case.events,
                timestamps = maps:put(updated_at, Now, Case#wf_case.timestamps)
            }
    end.

%%--------------------------------------------------------------------
%% @private
%% @doc Fires a transition with data.
%%
%% @end
%%--------------------------------------------------------------------
-spec fire_transition(atom(), map(), map()) -> pnet_types:produce_map().

fire_transition(Trsn, Data, Spec) ->
    Transitions = maps:get(transitions, Spec, #{}),
    case maps:get(Trsn, Transitions, undefined) of
        undefined -> #{};
        Def -> maps:get(produce, Def, #{})
    end.

%%--------------------------------------------------------------------
%% @private
%% @doc Consumes tokens from preset places.
%%
%% @end
%%--------------------------------------------------------------------
-spec consume_preset(pnet_types:marking(), [atom()]) -> pnet_types:marking().

consume_preset(Marking, []) -> Marking;
consume_preset(Marking, [Place | Rest]) ->
    Marking1 = maps:put(Place, [], Marking),
    consume_preset(Marking1, Rest).

%%--------------------------------------------------------------------
%% @private
%% @doc Applies a produce map to a marking.
%%
%% @end
%%--------------------------------------------------------------------
-spec apply_produce_map(pnet_types:marking(), pnet_types:produce_map()) ->
          pnet_types:marking().

apply_produce_map(Marking, ProduceMap) ->
    maps:fold(
        fun(Place, Tokens, Acc) ->
            Existing = maps:get(Place, Acc, []),
            maps:put(Place, Existing ++ Tokens, Acc)
        end,
        Marking,
        ProduceMap
    ).

%%--------------------------------------------------------------------
%% @private
%% @doc Generates a unique work item ID.
%%
%% @end
%%--------------------------------------------------------------------
-spec generate_wi_id() -> wi_id().

generate_wi_id() ->
    Unique = crypto:hash(md5, term_to_binary({self(), erlang:unique_integer()})),
    Hex = binary:encode_hex(Unique),
    <<"wi_", Hex/binary>>.

%%--------------------------------------------------------------------
%% @private
%% @doc Generates a unique request ID.
%%
%% @end
%%--------------------------------------------------------------------
-spec generate_req_id() -> binary().

generate_req_id() ->
    Unique = crypto:hash(md5, term_to_binary({self(), erlang:unique_integer()})),
    Hex = binary:encode_hex(Unique),
    <<"req_", Hex/binary>>.

%%--------------------------------------------------------------------
%% @private
%% @doc Injects a service reply as tokens.
%%
%% @end
%%--------------------------------------------------------------------
-spec inject_service_reply(wf_case(), binary(), term(), integer()) -> wf_case().

inject_service_reply(#wf_case{marking = Marking} = Case, _ReqId, Reply, Now) ->
    %% Inject reply token to service_reply place
    Marking1 = maps:put(service_reply, [Reply], Marking),
    Case1 = Case#wf_case{
        marking = Marking1,
        timestamps = maps:put(updated_at, Now, Case#wf_case.timestamps)
    },
    process_enabled(Case1, #{}, Now).

%%--------------------------------------------------------------------
%% @private
%% @doc Injects tokens from a produce map.
%%
%% @end
%%--------------------------------------------------------------------
-spec inject_tokens(wf_case(), pnet_types:produce_map(), integer()) -> wf_case().

inject_tokens(#wf_case{marking = Marking} = Case, ProduceMap, Now) ->
    Marking1 = apply_produce_map(Marking, ProduceMap),
    Case#wf_case{
        marking = Marking1,
        timestamps = maps:put(updated_at, Now, Case#wf_case.timestamps)
    }.
%%--------------------------------------------------------------------
%% @private
%% @doc Starts a scheduled case by transitioning it to running status.
%%
%% Called when the scheduled start time is reached. The case transitions
%% from 'scheduled' to 'running' and begins processing enabled transitions.
%%
%% @end
%%--------------------------------------------------------------------
-spec start_scheduled_case(wf_case(), map(), integer()) -> wf_case().

start_scheduled_case(#wf_case{marking = Marking, scheduled_at = ScheduledAt} = Case, Spec, Now) ->
    %% Update case to running status
    Timestamps = maps:put(started_at, Now, Case#wf_case.timestamps),
    
    Case1 = Case#wf_case{
        status = running,
        scheduled_at => undefined,
        timestamps = Timestamps
    },
    
    %% Process initial transitions (case is now active)
    process_enabled(Case1, Spec, Now).

