%% -*- erlang -*-
%%
%% CRE: common runtime environment for distributed programming languages
%%
%% Copyright 2015 JÃ¶rgen Brandt <joergen@cuneiform-lang.org>
%%
%% Licensed under the Apache License, Version 2.0 (the "License");
%% you may not use this file except in compliance with the License.
%% You may obtain a copy of the License at
%%
%%     http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing, software
%% distributed under the License is distributed on an "AS IS" BASIS,
%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%% See the License for the specific language governing permissions and
%% limitations under the License.
%%
%% -------------------------------------------------------------------
%% @author YAWL Workflow Module
%% @copyright 2025
%%
%% @doc YAWL (Yet Another Workflow Language) pattern support for CRE.
%%
%% This module provides the foundation for implementing YAWL workflow patterns
%% within the CRE distributed runtime environment. It defines core types,
%% records, and utility functions for creating and validating workflow patterns.
%%
%% The 43 YAWL workflow patterns are organized into the following categories:
%%
%% <b>Basic Control Flow Patterns (1-5):</b>
%% 1. Sequence
%% 2. Parallel Split
%% 3. Synchronization
%% 4. Exclusive Choice
%% 5. Simple Merge
%%
%% <b>Advanced Branch & Sync Patterns (6-10):</b>
%% 6. Multi-Choice
%% 7. Synchronizing Merge
%% 8. Multi-Merge
%% 9. Discriminator
%% 10. Arbitration (N-out-of-M Join)
%%
%% <b>Structural Patterns (11-14):</b>
%% 11. Arbitrary Cycles
%% 12. Implicit Termination
%% 13. Multiple Instances (without synchronization)
%% 14. Multiple Instances (with a priori design time knowledge)
%%
%% <b>State-Based Patterns (15-20):</b>
%% 15. Multiple Instances (with a priori runtime knowledge)
%% 16. Multiple Instances (without a priori runtime knowledge)
%% 17. Deferred Choice
%% 18. Interleaved Parallel Routing
%% 19. Milestone
%% 20. Cancel Activity
%%
%% <b>Extended Control Flow Patterns (21-28):</b>
%% 21. Cancel Case
%% 22. Cancel Region
%% 23. Cancel Multiple Instance Activity
%% 24. Complete (Partial) Multiple Instance Activity
%% 25. Structured Loop
%% 26. Recursion
%% 27. Multi-Merge (with configurations)
%% 28. Critical Section
%%
%% <b>Data Flow Patterns (29-33):</b>
%% 29. Data Transformation
%% 30. Data Visibility (Shared Data)
%% 31. Data Visibility (Data Passing)
%% 32. Data Visibility (Data Distribution)
%% 33. Data Interaction (Data Exchange)
%%
%% <b>Resource Patterns (34-38):</b>
%% 34. Direct Distribution
%% 35. Late Distribution
%% 36. Persistent Distribution
%% 37. Create Instance
%% 38. Role-Based Distribution
%%
%% <b>Exception Handling Patterns (39-43):</b>
%% 39. Retry Mechanism
%% 40. Retry Loop
%% 41. Compensate
%% 42. Compensate+Cancel
%% 43. Critical Exception Handler
%%
%% @end
%% -------------------------------------------------------------------

-module(cre_yawl).

%%====================================================================
%% Exports
%%====================================================================

%% Workflow creation API
-export([new_workflow/0,
         new_workflow/1]).

%% Workflow element manipulation
-export([add_task/3,
         add_condition/3,
         set_split_type/3,
         set_join_type/3,
         connect/3]).

%% Workflow validation
-export([validate/1,
         get_errors/1]).

%% Pattern constructors
-export([sequence/0,
         parallel_split/0,
         synchronization/0,
         exclusive_choice/0,
         simple_merge/0,
         multi_choice/0,
         synchronizing_merge/0,
         multi_merge/0,
         discriminator/0,
         arbitration/0]).

%%====================================================================
%% Type Definitions
%%====================================================================

-type join_type() :: and_join | or_join | xor_join.
%% Defines how multiple incoming branches are combined.
%% <ul>
%% <li>`and_join': All incoming branches must complete</li>
%% <li>`or_join': One or more incoming branches must complete</li>
%% <li>`xor_join': Exactly one incoming branch must complete</li>
%% </ul>

-type split_type() :: and_split | or_split | xor_split.
%% Defines how execution splits into multiple branches.
%% <ul>
%% <li>`and_split': All branches execute in parallel</li>
%% <li>`or_split': One or more branches execute based on conditions</li>
%% <li>`xor_split': Exactly one branch executes based on condition</li>
%% </ul>

-type condition() :: binary() | {atom(), term()} | fun(() -> boolean()).
%% A condition expression that evaluates to true or false.
%% Can be a binary expression, a tuple {function_name, arguments},
%% or an anonymous function.

-type element_id() :: binary().
%% Unique identifier for a workflow element (task or condition).

-type task_type() :: atomic | composite | subworkflow | multi_instance.
%% Classification of task types.

%% Record types are implicitly defined by their record declarations.
%% For documentation purposes:
%% - #task{}: A workflow task definition
%% - #yawl_condition{}: A workflow condition definition
%% - #connection{}: A directed connection between workflow elements
%% - #workflow{}: Complete workflow definition containing all elements
%% - #sequence{}, #parallel_split{}, etc.: Pattern-specific records

-type pattern() :: #workflow{} | #sequence{} | #parallel_split{} |
                   #synchronization{} | #exclusive_choice{} |
                   #simple_merge{} | #multi_choice{} |
                   #synchronizing_merge{} | #multi_merge{} |
                   #discriminator{} | #arbitration{}.
%% Union type for all YAWL pattern types.

%%====================================================================
%% Record Definitions
%%====================================================================

%% @doc Task record representing a single workflow task.
%% <ul>
%% <li>`id': Unique identifier for the task</li>
%% <li>`name': Human-readable name</li>
%% <li>`type': Task classification (atomic, composite, etc.)</li>
%% <li>`split_type': How execution splits after this task</li>
%% <li>`join_type': How multiple incoming branches are joined</li>
%% <li>`metadata': Additional task properties</li>
%% </ul>
-record(task, {
          id :: element_id(),
          name :: binary(),
          type :: task_type(),
          split_type :: split_type() | undefined,
          join_type :: join_type() | undefined,
          metadata = #{} :: #{atom() => term()}
         }).

%% @doc Condition record representing a workflow condition/branch point.
%% <ul>
%% <li>`id': Unique identifier for the condition</li>
%% <li>`expression': The condition expression</li>
%% <li>`description': Human-readable description</li>
%% </ul>
-record(yawl_condition, {
          id :: element_id(),
          expression :: condition(),
          description :: binary() | undefined
         }).

%% @doc Connection record representing a directed edge in the workflow graph.
%% <ul>
%% <li>`from_id': Source element identifier</li>
%% <li>`to_id': Destination element identifier</li>
%% <li>`condition_id': Optional condition guarding this connection</li>
%% </ul>
-record(connection, {
          from_id :: element_id(),
          to_id :: element_id(),
          condition_id :: element_id() | undefined
         }).

%% @doc Workflow record representing a complete workflow definition.
%% <ul>
%% <li>`id': Unique workflow identifier</li>
%% <li>`name': Human-readable workflow name</li>
%% <li>`tasks': Map of task_id to task records</li>
%% <li>`conditions': Map of condition_id to condition records</li>
%% <li>`connections': List of connection records</li>
%% <li>`start_task_id': ID of the workflow entry point</li>
%% <li>`end_task_ids': List of workflow exit points</li>
%% </ul>
-record(workflow, {
          id :: element_id(),
          name :: binary(),
          tasks = #{} :: #{element_id() => #task{}},
          conditions = #{} :: #{element_id() => #yawl_condition{}},
          connections = [] :: [#connection{}],
          start_task_id :: element_id() | undefined,
          end_task_ids = [] :: [element_id()]
         }).

%% @doc Sequence pattern - tasks execute one after another.
-record(sequence, {
          task_ids :: [element_id()]
         }).

%% @doc Parallel split pattern - execution splits into parallel branches.
-record(parallel_split, {
          split_task_id :: element_id(),
          branch_task_ids :: [element_id()]
         }).

%% @doc Synchronization pattern - parallel branches join into single flow.
-record(synchronization, {
          join_task_id :: element_id(),
          incoming_task_ids :: [element_id()]
         }).

%% @doc Exclusive choice pattern - one branch selected based on condition.
-record(exclusive_choice, {
          choice_task_id :: element_id(),
          branches :: [{element_id(), condition()}]
         }).

%% @doc Simple merge pattern - multiple incoming paths merge without sync.
-record(simple_merge, {
          merge_task_id :: element_id(),
          incoming_task_ids :: [element_id()]
         }).

%% @doc Multi-choice pattern - multiple branches selected based on conditions.
-record(multi_choice, {
          choice_task_id :: element_id(),
          branches :: [{element_id(), condition()}]
         }).

%% @doc Synchronizing merge - merges multiple paths with synchronization.
-record(synchronizing_merge, {
          merge_task_id :: element_id(),
          incoming_task_ids :: [element_id()]
         }).

%% @doc Multi-merge - multiple incoming paths merge individually.
-record(multi_merge, {
          merge_task_id :: element_id(),
          incoming_task_ids :: [element_id()]
         }).

%% @doc Discriminator - waits for first incoming branch, then continues.
-record(discriminator, {
          merge_task_id :: element_id(),
          incoming_task_ids :: [element_id()]
         }).

%% @doc Arbitration (N-out-of-M) - waits for N of M incoming branches.
-record(arbitration, {
          merge_task_id :: element_id(),
          incoming_task_ids :: [element_id()],
          required_count :: pos_integer()
         }).

%%====================================================================
%% API Functions
%%====================================================================

%%--------------------------------------------------------------------
%% @doc Creates a new empty workflow with a generated ID.
%% @end
%%--------------------------------------------------------------------
-spec new_workflow() -> #workflow{}.

new_workflow() ->
    WorkflowId = generate_id(<<"workflow">>),
    new_workflow(WorkflowId).

%%--------------------------------------------------------------------
%% @doc Creates a new empty workflow with the specified ID.
%% @end
%%--------------------------------------------------------------------
-spec new_workflow(Id :: element_id()) -> #workflow{}.

new_workflow(Id) when is_binary(Id) ->
    #workflow{
       id = Id,
       name = <<"Untitled Workflow">>
      }.

%%--------------------------------------------------------------------
%% @doc Adds a task to the workflow.
%% @end
%%--------------------------------------------------------------------
-spec add_task(Workflow :: #workflow{},
               TaskId :: element_id(),
               Task :: #task{} | [{atom(), term()}]) -> #workflow{}.

add_task(#workflow{tasks = Tasks} = Workflow, TaskId, TaskRec)
  when is_record(TaskRec, task) ->
    Workflow#workflow{tasks = Tasks#{TaskId => TaskRec}};

add_task(Workflow, TaskId, PropList) when is_list(PropList) ->
    Task = make_task(TaskId, PropList),
    add_task(Workflow, TaskId, Task).

%%--------------------------------------------------------------------
%% @doc Adds a condition to the workflow.
%% @end
%%--------------------------------------------------------------------
-spec add_condition(Workflow :: #workflow{},
                    ConditionId :: element_id(),
                    Condition :: #yawl_condition{} | condition()) -> #workflow{}.

add_condition(#workflow{conditions = Conds} = Workflow,
              ConditionId,
              CondRec) when is_record(CondRec, yawl_condition) ->
    Workflow#workflow{conditions = Conds#{ConditionId => CondRec}};

add_condition(Workflow, ConditionId, Expression) ->
    CondRec = #yawl_condition{id = ConditionId, expression = Expression},
    add_condition(Workflow, ConditionId, CondRec).

%%--------------------------------------------------------------------
%% @doc Sets the split type for a task.
%% @end
%%--------------------------------------------------------------------
-spec set_split_type(Workflow :: #workflow{},
                     TaskId :: element_id(),
                     SplitType :: split_type()) -> #workflow{}.

set_split_type(#workflow{tasks = Tasks} = Workflow, TaskId, SplitType)
  when is_binary(TaskId), (SplitType =:= and_split orelse
                           SplitType =:= or_split orelse
                           SplitType =:= xor_split) ->
    case maps:get(TaskId, Tasks, undefined) of
        undefined ->
            Workflow;
        Task ->
            Workflow#workflow{tasks = Tasks#{TaskId => Task#task{split_type = SplitType}}}
    end.

%%--------------------------------------------------------------------
%% @doc Sets the join type for a task.
%% @end
%%--------------------------------------------------------------------
-spec set_join_type(Workflow :: #workflow{},
                    TaskId :: element_id(),
                    JoinType :: join_type()) -> #workflow{}.

set_join_type(#workflow{tasks = Tasks} = Workflow, TaskId, JoinType)
  when is_binary(TaskId), (JoinType =:= and_join orelse
                           JoinType =:= or_join orelse
                           JoinType =:= xor_join) ->
    case maps:get(TaskId, Tasks, undefined) of
        undefined ->
            Workflow;
        Task ->
            Workflow#workflow{tasks = Tasks#{TaskId => Task#task{join_type = JoinType}}}
    end.

%%--------------------------------------------------------------------
%% @doc Creates a connection between two workflow elements.
%% @end
%%--------------------------------------------------------------------
-spec connect(Workflow :: #workflow{},
              FromId :: element_id(),
              ToId :: element_id()) -> #workflow{}.

connect(#workflow{connections = Conns} = Workflow, FromId, ToId)
  when is_binary(FromId), is_binary(ToId) ->
    Conn = #connection{from_id = FromId, to_id = ToId},
    Workflow#workflow{connections = [Conn | Conns]}.

%%--------------------------------------------------------------------
%% @doc Validates the workflow structure and returns ok or {error, Reason}.
%% @end
%%--------------------------------------------------------------------
-spec validate(Workflow :: #workflow{}) -> ok | {error, [binary()]}.

validate(#workflow{} = Workflow) ->
    case validate_workflow(Workflow) of
        [] -> ok;
        Errors -> {error, Errors}
    end.

%%--------------------------------------------------------------------
%% @doc Returns a list of validation errors for the workflow.
%% @end
%%--------------------------------------------------------------------
-spec get_errors(Workflow :: #workflow{}) -> [binary()].

get_errors(#workflow{} = Workflow) ->
    validate_workflow(Workflow).

%%--------------------------------------------------------------------
%% @doc Creates a sequence pattern.
%% @end
%%--------------------------------------------------------------------
-spec sequence() -> #sequence{}.

sequence() ->
    #sequence{task_ids = []}.

%%--------------------------------------------------------------------
%% @doc Creates a parallel split pattern.
%% @end
%%--------------------------------------------------------------------
-spec parallel_split() -> #parallel_split{}.

parallel_split() ->
    #parallel_split{split_task_id = <<>>, branch_task_ids = []}.

%%--------------------------------------------------------------------
%% @doc Creates a synchronization pattern.
%% @end
%%--------------------------------------------------------------------
-spec synchronization() -> #synchronization{}.

synchronization() ->
    #synchronization{join_task_id = <<>>, incoming_task_ids = []}.

%%--------------------------------------------------------------------
%% @doc Creates an exclusive choice pattern.
%% @end
%%--------------------------------------------------------------------
-spec exclusive_choice() -> #exclusive_choice{}.

exclusive_choice() ->
    #exclusive_choice{choice_task_id = <<>>, branches = []}.

%%--------------------------------------------------------------------
%% @doc Creates a simple merge pattern.
%% @end
%%--------------------------------------------------------------------
-spec simple_merge() -> #simple_merge{}.

simple_merge() ->
    #simple_merge{merge_task_id = <<>>, incoming_task_ids = []}.

%%--------------------------------------------------------------------
%% @doc Creates a multi-choice pattern.
%% @end
%%--------------------------------------------------------------------
-spec multi_choice() -> #multi_choice{}.

multi_choice() ->
    #multi_choice{choice_task_id = <<>>, branches = []}.

%%--------------------------------------------------------------------
%% @doc Creates a synchronizing merge pattern.
%% @end
%%--------------------------------------------------------------------
-spec synchronizing_merge() -> #synchronizing_merge{}.

synchronizing_merge() ->
    #synchronizing_merge{merge_task_id = <<>>, incoming_task_ids = []}.

%%--------------------------------------------------------------------
%% @doc Creates a multi-merge pattern.
%% @end
%%--------------------------------------------------------------------
-spec multi_merge() -> #multi_merge{}.

multi_merge() ->
    #multi_merge{merge_task_id = <<>>, incoming_task_ids = []}.

%%--------------------------------------------------------------------
%% @doc Creates a discriminator pattern.
%% @end
%%--------------------------------------------------------------------
-spec discriminator() -> #discriminator{}.

discriminator() ->
    #discriminator{merge_task_id = <<>>, incoming_task_ids = []}.

%%--------------------------------------------------------------------
%% @doc Creates an arbitration (N-out-of-M) pattern.
%% @end
%%--------------------------------------------------------------------
-spec arbitration() -> #arbitration{}.

arbitration() ->
    #arbitration{merge_task_id = <<>>, incoming_task_ids = [], required_count = 1}.

%%====================================================================
%% Internal Functions
%%====================================================================

%%--------------------------------------------------------------------
%% @private
%% @doc Generates a unique identifier for workflow elements.
%% @end
%%--------------------------------------------------------------------
-spec generate_id(Prefix :: binary()) -> element_id().

generate_id(Prefix) ->
    Unique = crypto:hash(md5, term_to_binary({self(), erlang:timestamp()})),
    Hex = binary:encode_hex(Unique),
    <<Prefix/binary, "_", Hex/binary>>.

%%--------------------------------------------------------------------
%% @private
%% @doc Creates a task record from a property list.
%% @end
%%--------------------------------------------------------------------
-spec make_task(TaskId :: element_id(), PropList :: [{atom(), term()}]) -> #task{}.

make_task(TaskId, PropList) ->
    Name = proplists:get_value(name, PropList, <<"Unnamed Task">>),
    Type = proplists:get_value(type, PropList, atomic),
    SplitType = proplists:get_value(split_type, PropList, undefined),
    JoinType = proplists:get_value(join_type, PropList, undefined),
    Metadata = proplists:get_value(metadata, PropList, #{}),
    #task{
       id = TaskId,
       name = Name,
       type = Type,
       split_type = SplitType,
       join_type = JoinType,
       metadata = Metadata
      }.

%%--------------------------------------------------------------------
%% @private
%% @doc Performs comprehensive workflow validation.
%% @end
%%--------------------------------------------------------------------
-spec validate_workflow(#workflow{}) -> [binary()].

validate_workflow(#workflow{tasks = Tasks,
                            connections = Conns,
                            start_task_id = StartTaskId,
                            end_task_ids = EndTaskIds}) ->
    Errors1 = validate_tasks_exist(Tasks, Conns),
    Errors2 = validate_start_task(StartTaskId, Tasks),
    Errors3 = validate_end_tasks(EndTaskIds, Tasks),
    Errors4 = validate_connections(Conns, Tasks),
    Errors5 = validate_no_cycles(Conns),
    Errors6 = validate_split_join_consistency(Tasks, Conns),
    lists:flatten([Errors1, Errors2, Errors3, Errors4, Errors5, Errors6]).

%%--------------------------------------------------------------------
%% @private
%% @doc Validates that all tasks referenced in connections exist.
%% @end
%%--------------------------------------------------------------------
-spec validate_tasks_exist(#{element_id() => #task{}}, [#connection{}]) -> [binary()].

validate_tasks_exist(Tasks, Conns) ->
    TaskIds = maps:keys(Tasks),
    F = fun(#connection{from_id = From, to_id = To}, Acc) ->
            Acc1 = case lists:member(From, TaskIds) of
                       false -> [<<"Task '", From/binary, "' referenced in connection does not exist">> | Acc];
                       true -> Acc
                   end,
            case lists:member(To, TaskIds) of
                false -> [<<"Task '", To/binary, "' referenced in connection does not exist">> | Acc1];
                true -> Acc1
            end
        end,
    lists:foldl(F, [], Conns).

%%--------------------------------------------------------------------
%% @private
%% @doc Validates the start task exists if specified.
%% @end
%%--------------------------------------------------------------------
-spec validate_start_task(element_id() | undefined, #{element_id() => #task{}}) -> [binary()].

validate_start_task(undefined, _Tasks) ->
    [];
validate_start_task(StartTaskId, Tasks) ->
    case maps:is_key(StartTaskId, Tasks) of
        false -> [<<"Start task '", StartTaskId/binary, "' does not exist">>];
        true -> []
    end.

%%--------------------------------------------------------------------
%% @private
%% @doc Validates that all end tasks exist.
%% @end
%%--------------------------------------------------------------------
-spec validate_end_tasks([element_id()], #{element_id() => #task{}}) -> [binary()].

validate_end_tasks([], _Tasks) ->
    [];
validate_end_tasks(EndTaskIds, Tasks) ->
    F = fun(TaskId, Acc) ->
            case maps:is_key(TaskId, Tasks) of
                false -> [<<"End task '", TaskId/binary, "' does not exist">> | Acc];
                true -> Acc
            end
        end,
    lists:foldl(F, [], EndTaskIds).

%%--------------------------------------------------------------------
%% @private
%% @doc Validates connection integrity.
%% @end
%%--------------------------------------------------------------------
-spec validate_connections([#connection{}], #{element_id() => #task{}}) -> [binary()].

validate_connections(Conns, Tasks) ->
    F = fun(#connection{from_id = From, to_id = To}, Acc) ->
            %% Check for self-loops
            Acc1 = case From =:= To of
                       true -> [<<"Self-loop detected on task '", From/binary, "'">> | Acc];
                       false -> Acc
                   end,
            %% Check for duplicate connections
            case lists:any(fun(C) ->
                               C#connection.from_id =:= From andalso
                               C#connection.to_id =:= To
                           end, Conns -- [#connection{from_id = From, to_id = To}]) of
                true -> [<<"Duplicate connection from '", From/binary, "' to '", To/binary, "'">> | Acc1];
                false -> Acc1
            end
        end,
    lists:foldl(F, [], Conns).

%%--------------------------------------------------------------------
%% @private
%% @doc Validates that the workflow has no cycles (basic check).
%% @end
%%--------------------------------------------------------------------
-spec validate_no_cycles([#connection{}]) -> [binary()].

validate_no_cycles([]) ->
    [];
validate_no_cycles(Conns) ->
    %% Build adjacency list
    F = fun(#connection{from_id = From, to_id = To}, Acc) ->
            Acc#{From => [To | maps:get(From, Acc, [])]}
        end,
    Graph = lists:foldl(F, #{}, Conns),
    Nodes = lists:usort([N || #connection{from_id = N, to_id = T} <- Conns] ++
                         [T || #connection{from_id = N, to_id = T} <- Conns]),
    case detect_cycle(Graph, Nodes, [], #{}) of
        {cycle, Node} -> [<<"Cycle detected in workflow involving task '", Node/binary, "'">>];
        no_cycle -> []
    end.

%%--------------------------------------------------------------------
%% @private
%% @doc Depth-first search to detect cycles in the workflow graph.
%% @end
%%--------------------------------------------------------------------
-spec detect_cycle(#{element_id() => [element_id()]},
                   [element_id()],
                   [element_id()],
                   #{element_id() => visiting | visited}) ->
          {cycle, element_id()} | no_cycle.

detect_cycle(_Graph, [], _Path, _Visited) ->
    no_cycle;
detect_cycle(Graph, [Node | Rest], Path, Visited) ->
    case maps:get(Node, Visited, undefined) of
        visiting ->
            {cycle, Node};
        visited ->
            detect_cycle(Graph, Rest, Path, Visited);
        undefined ->
            Visited1 = Visited#{Node => visiting},
            Neighbors = maps:get(Node, Graph, []),
            case detect_cycle(Graph, Neighbors, [Node | Path], Visited1) of
                {cycle, _} = Cycle -> Cycle;
                no_cycle ->
                    Visited2 = Visited1#{Node => visited},
                    detect_cycle(Graph, Rest, Path, Visited2)
            end
    end.

%%--------------------------------------------------------------------
%% @private
%% @doc Validates consistency between split and join types with connections.
%% @end
%%--------------------------------------------------------------------
-spec validate_split_join_consistency(#{element_id() => #task{}},
                                      [#connection{}]) -> [binary()].

validate_split_join_consistency(Tasks, Conns) ->
    %% For each task, validate split/join type matches actual connections
    F = fun(TaskId, Task, Acc) ->
            SplitErrors = validate_split_type(TaskId, Task, Conns),
            JoinErrors = validate_join_type(TaskId, Task, Conns),
            Acc ++ SplitErrors ++ JoinErrors
        end,
    maps:fold(F, [], Tasks).

%%--------------------------------------------------------------------
%% @private
%% @doc Validates that a task's split type matches its outgoing connections.
%% @end
%%--------------------------------------------------------------------
-spec validate_split_type(element_id(), #task{}, [#connection{}]) -> [binary()].

validate_split_type(_TaskId, #task{split_type = undefined}, _Conns) ->
    [];
validate_split_type(TaskId, #task{split_type = SplitType}, Conns) ->
    OutgoingCount = length([C || #connection{from_id = F} <- Conns, F =:= TaskId]),
    NBin = integer_to_binary(OutgoingCount),
    case {SplitType, OutgoingCount} of
        {xor_split, N} when N > 1 ->
            [iolist_to_binary([<<"XOR split on task '">>, TaskId, <<"' has ">>,
                              NBin, <<" outgoing connections (should be 1 per branch)">>])];
        {and_split, N} when N < 2 ->
            [iolist_to_binary([<<"AND split on task '">>, TaskId,
                              <<"' requires at least 2 outgoing connections, found ">>, NBin])];
        {or_split, N} when N < 2 ->
            [iolist_to_binary([<<"OR split on task '">>, TaskId,
                              <<"' requires at least 2 outgoing connections, found ">>, NBin])];
        _ ->
            []
    end.

%%--------------------------------------------------------------------
%% @private
%% @doc Validates that a task's join type matches its incoming connections.
%% @end
%%--------------------------------------------------------------------
-spec validate_join_type(element_id(), #task{}, [#connection{}]) -> [binary()].

validate_join_type(_TaskId, #task{join_type = undefined}, _Conns) ->
    [];
validate_join_type(TaskId, #task{join_type = JoinType}, Conns) ->
    IncomingCount = length([C || #connection{to_id = T} <- Conns, T =:= TaskId]),
    case {JoinType, IncomingCount} of
        {xor_join, N} when N > 1 ->
            [<<"XOR join on task '", TaskId/binary, "' has ", (integer_to_binary(N))/binary,
              " incoming connections (should have exactly 1)">>];
        {and_join, N} when N < 2 ->
            [<<"AND join on task '", TaskId/binary, "' requires at least 2 incoming connections, found ",
              (integer_to_binary(N))/binary>>;
        {or_join, N} when N < 2 ->
            [<<"OR join on task '", TaskId/binary, "' requires at least 2 incoming connections, found ",
              (integer_to_binary(N))/binary>>;
        _ ->
            []
    end.
